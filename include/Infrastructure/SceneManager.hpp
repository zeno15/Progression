#ifndef INCLUDED_INFRASTRUCTURE_SCENE_MANAGER_HPP_
#define INCLUDED_INFRASTRUCTURE_SCENE_MANAGER_HPP_

#include <string>

#include <Infrastructure/Scene.hpp>
#include <Infrastructure/Manager.hpp>

////////////////////////////////////////////////////////////
///
///	\namespace Infrastructure
///
////////////////////////////////////////////////////////////
namespace Infrastructure {
	////////////////////////////////////////////////////////////
	///
	///	\brief	Class to manage multiple scenes
	///
	////////////////////////////////////////////////////////////
	class SceneManager : public Manager {
	public:
		friend class InstanceCollection;

		const static std::string Name;			///<	Name of the manager

		////////////////////////////////////////////////////////////
		///
		///	\brief	Updates all the scenes
		///
		///	\param	The elapsed time for the update
		///
		////////////////////////////////////////////////////////////
		void update(float _delta);
		////////////////////////////////////////////////////////////
		///
		///	\brief	Handles an event for all the scenes
		///
		///	\param	The event to be handled
		///
		///	\return	Whether the event was handled
		///
		////////////////////////////////////////////////////////////
		bool handleEvent(const System::Event& _event);
		////////////////////////////////////////////////////////////
		///
		///	\brief	Draws all the scenes
		///
		///	\param	The target to draw on
		///
		///	\param	The states to draw with
		///
		////////////////////////////////////////////////////////////
		void draw(Window::Window& _window, Graphics::RenderData _states) const;

		////////////////////////////////////////////////////////////
		///
		///	\brief	Adds a scene to the manager
		///
		///	\param	The scene to add
		///
		////////////////////////////////////////////////////////////
		void addScene(Scene *_scene);
		////////////////////////////////////////////////////////////
		///
		///	\brief	Removes a scene from the manager
		///
		///	\param	The scene to remove
		///
		////////////////////////////////////////////////////////////
		void removeScene(Scene *_scene);

		////////////////////////////////////////////////////////////
		///
		///	\brief	Sets the active scene
		///
		///	\param	The scene to be activated
		///
		////////////////////////////////////////////////////////////
		void setActiveScene(Scene *_scene);
		////////////////////////////////////////////////////////////
		///
		///	\brief	Gets the current active scene
		///
		///	\return	The active scene
		///
		////////////////////////////////////////////////////////////
		Scene& getActiveScene(void);

		////////////////////////////////////////////////////////////
		///
		///	\brief	Gets a scene by name
		///
		///	\param	The name of the scene to get
		///
		///	\return The scene
		///
		////////////////////////////////////////////////////////////
		Scene& getScene(const std::string& _name);

		////////////////////////////////////////////////////////////
		///
		///	\brief	Gets a scene by name converted to a type
		///
		///	\tparam	The type to cast the scene to
		///
		///	\param	The name of the scene to get
		///
		///	\return The scene
		///
		////////////////////////////////////////////////////////////
		template <typename T>
		T& getScene(const std::string& _name) {
			for (auto& scene : m_Scenes) {
				if (scene->getName() == _name) {
					return *static_cast<T *>(scene);
				}
			}

			throw std::runtime_error(std::string("Failed to find scene " + _name));
		}

	private:
		////////////////////////////////////////////////////////////
		///
		///	\brief	Constructor
		///
		////////////////////////////////////////////////////////////
		SceneManager();
		////////////////////////////////////////////////////////////
		///
		///	\brief	Destructor
		///
		////////////////////////////////////////////////////////////
		~SceneManager();

		std::vector<Scene *> m_Scenes;				///< 
		Scene *m_CurrentScene;						///<	
	};
}

#endif // INCLUDED_INFRASTRUCTURE_SCENE_MANAGER_HPP_